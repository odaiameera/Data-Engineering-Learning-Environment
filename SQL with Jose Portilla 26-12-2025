-- Section 3 and Assessement

-- Aggregation Functions
SELECT MIN(replacement_cost) FROM film
SELECT MAX(replacement_cost) FROM film
SELECT MAX(replacement_cost), MIN(replacement_cost)
FROM film;

SELECT COUNT (*)
FROM film;

SELECT ROUND (AVG(replacement_cost),2)
FROM film;

SELECT SUM (replacement_cost)
FROM film;

SELECT ROUND (SUM (replacement_cost),2)
FROM film;

-- GROUP BY
-- General Syntax 
SELECT category_col, AGG(data_col)
FROM table 
WHERE category_col = 'A'
GROUP BY category_col
-- The GROUP BY clause must appear right after a FROM or WHERE statement 
-- In the SELECT statement, columns must euther have an aggregate function or be in the GROUP BY call
SELECT company, division, SUM(sales)
FROM finance_table
GROUP BY company, division 
-- WHERE statements should not refer tomtha aggregation result, later on we will learn use HAVING to filter on those results 
SELECT company, division, SUM (sales)
FROM finance_table
WHERE division IN ('marketing','transport')
GROUP BY company, division 
-- If you want to sort results based on the aggregate, make sure to reference the entire function 
SELECT company, SUM(sales)
FROM  finance_table 
GROUP BY company 
ORDER BY SUM(sales)
LIMIT 5; 

SELECT * FROM payment

SELECT customer_id FROM payment
GROUP BY customer_id
ORDER BY customer_id;

-- To check how much each customer paid
SELECT customer_id, SUM(amount)
FROM payment 
GROUP BY customer_id
ORDER BY SUM (amount) DESC ;

-- To check the total of transactions 
SELECT customer_id, COUNT(amount)
FROM payment 
GROUP BY customer_id
ORDER BY SUM (amount) ASC;
_________________________
SELECT * FROM payment;
_________________________
-- To check how much each customer paid with a staff member 
SELECT customer_id, staff_id, SUM(amount)
FROM payment
GROUP BY staff_id, customer_id
ORDER BY customer_id;
_________________________
-- To GROUB BY  a date 
SELECT DATE(payment_date) , SUM (amount)
FROM payment 
GROUP BY DATE (payment_date)
ORDER BY SUM (amount) DESC

-- Challenge Tasks 
-- 1. We have two staff members, with Staff IDs 1 and 2. We want to give a bonus to the staff member that handled the most payments, 
-- (Most in terms of number of payments process, not total dollar amount)
-- How many payment did each staff member handle and who gets the bonus

SELECT staff_id, COUNT(payment_id)
FROM payment 
GROUP BY staff_id
ORDER BY COUNT (payment_id) DESC
LIMIT 2; -- <-- LIMIT was  not needed, but when it is a large table, limit will give me quicker results 
-- Another correct solution was to use COUNT(*) OR COUNT(amount)
-- COUNT will always give us the number of rows which either way will give us the same result 

-- 2. Corporate HQ is conducting a study on the relationship between replacement cost and a movie MPPAA rating
-- What is the average replacement cost per MPAA rating? 

SELECT * FROM film;
__
SELECT rating, ROUND (AVG(replacement_cost)) AS AVG_Cost
FROM film 
GROUP BY rating
ORDER BY avg_cost ASC 

-- 3. We are running a promotion to reward our top 5 customers with coupons 
-- What are the customer ids of the top 5 customers by total spend?

SELECT * FROM payment

SELECT customer_id, SUM (amount) AS Total_spend
FROM payment
GROUP BY customer_id
ORDER BY Total_spend DESC 
LIMIT 5;

-- Gemini Challenge - Based on the query you wrote for Challenge 1, where would you place the HAVING clause in this structure?
SELECT staff_id, COUNT(payment_id)
FROM payment
GROUP BY staff_id
HAVING COUNT(payment_id) > 1000  -- What goes in the blank?
ORDER BY COUNT(payment_id) DESC;

-- HAVING Clause 
-- The HAVING clause allows us to filter after an aggregation has taken place

SELECT customer_id, SUM(amount)
FROM payment 
GROUP BY customer_id
HAVING SUM(amount) <= 50

SELECT * from customer
SELECT store_id, COUNT(*) AS frequent_customers
FROM customer
GROUP BY store_id
HAVING COUNT (*) > 300; -- HAVING happens before the SELECT statement, so it does not know what frequent_customers is yet, so you i should always 
-- code the raw aggregate function into the HAVING clause - and the SQL will be happy to use my alias after 

-- HAVING Challenge 
-- 1. We are launching a platinum service for our most loyal customers. We will assign platinum status to customers that have had 40 or more tranx
-- payment. What customer_ids are eligible for platinum status?

-- This is by total spend which is correct syntax but thats not what the questions wants
SELECT customer_id AS Eligible_customers, SUM(amount) AS Total_spend
FROM payment 
GROUP BY Eligible_customers
HAVING SUM(amount) >= 40
ORDER BY Total_spend ASC;

-- Solution 
SELECT customer_id AS Eligible_customer_ids, COUNT(amount) AS Total_Tranx
FROM payment 
GROUP BY Eligible_customer_ids
HAVING COUNT(amount) >= 40
ORDER BY Total_tranx ASC;

-- 2. What are the customer IDs of customers who have spent more than $100 in payment tranx with our staff member 2
SELECT staff_id, customer_id, SUM(amount) 
FROM payment 
WHERE staff_id = 2
GROUP BY staff_id, customer_id
HAVING SUM(amount) > 100

-- Assessement Test 

-- 1. Return the customer IDs of customers who have spent at least $110 with the staff member who has an ID of 2.

SELECT customer_id, SUM(amount)
FROM payment
WHERE staff_id = 2
GROUP BY customer_id
HAVING SUM(amount) >= 110;

-- 2. How many films begin with the letter J?

SELECT COUNT(film_id)
FROM film
WHERE title LIKE 'J%'

-- 3. What customer has the highest customer ID number whose name starts with an 'E' and has an address ID lower than 500?
SELECT customer_id, first_name, last_name
FROM customer 
WHERE first_name LIKE 'E%' AND address_id < 500
ORDER BY customer_ID DESC 
LIMIT 1;

-- SECTION 3 and 4 (Assessment) COMPLETED 